

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <link rel="canonical" href="http://tutorials.pytorch.kr/advanced/cpp_extension.html" />
  <meta charset="utf-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Custom C++ and CUDA Extensions &mdash; PyTorch Tutorials 0.4.0 documentation</title>

















    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />



    <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />

    <link rel="stylesheet" href="../_static/css/pytorch_theme.css" type="text/css" />

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato" type="text/css" />



        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="PyTorch Tutorials 0.4.0 documentation" href="../index.html"/>
        <link rel="prev" title="Transfering a model from PyTorch to Caffe2 and Mobile using ONNX" href="super_resolution_with_caffe2.html"/>


  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">


  <div class="wy-grid-for-nav">


    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">



            <a href="../index.html" class="icon icon-home"> PyTorch Tutorials




            <img src="../_static/pytorch-logo-dark.svg" class="logo" />

          </a>




              <div class="version">
                0.4.0
              </div>




<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>


        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">






              <p class="caption"><span class="caption-text">Beginner Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../beginner/deep_learning_60min_blitz.html">PyTorch로 딥러닝하기: 60분만에 끝장내기</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../beginner/blitz/tensor_tutorial.html">PyTorch가 무엇인가요?</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../beginner/blitz/tensor_tutorial.html#id1">시작하기</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../beginner/blitz/tensor_tutorial.html#tensors">Tensors</a></li>
<li class="toctree-l4"><a class="reference internal" href="../beginner/blitz/tensor_tutorial.html#operations">연산(Operations)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/blitz/tensor_tutorial.html#numpy-bridge">NumPy 변환(Bridge)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../beginner/blitz/tensor_tutorial.html#torch-tensor-numpy">Torch Tensor를 NumPy 배열로 변환하기</a></li>
<li class="toctree-l4"><a class="reference internal" href="../beginner/blitz/tensor_tutorial.html#numpy-torch-tensor">NumPy 배열을 Torch Tensor로 변환하기</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/blitz/tensor_tutorial.html#cuda-tensors">CUDA Tensors</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../beginner/blitz/autograd_tutorial.html">Autograd: 자동 미분</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../beginner/blitz/autograd_tutorial.html#tensor">Tensor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/blitz/autograd_tutorial.html#gradient">변화도(Gradient)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../beginner/blitz/neural_networks_tutorial.html">신경망(Neural Networks)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../beginner/blitz/neural_networks_tutorial.html#id1">신경망 정의하기</a></li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/blitz/neural_networks_tutorial.html#loss-function">손실 함수 (Loss Function)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/blitz/neural_networks_tutorial.html#backprop">역전파(Backprop)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/blitz/neural_networks_tutorial.html#id4">가중치 갱신</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../beginner/blitz/cifar10_tutorial.html">분류기(Classifier) 학습하기</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../beginner/blitz/cifar10_tutorial.html#id1">데이터는 어떻게 하나요?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/blitz/cifar10_tutorial.html#id2">이미지 분류기 학습하기</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../beginner/blitz/cifar10_tutorial.html#cifar10">1. CIFAR10를 불러오고 정규화하기</a></li>
<li class="toctree-l4"><a class="reference internal" href="../beginner/blitz/cifar10_tutorial.html#convolution-neural-network">2. 합성곱 신경망(Convolution Neural Network) 정의하기</a></li>
<li class="toctree-l4"><a class="reference internal" href="../beginner/blitz/cifar10_tutorial.html#optimizer">3. 손실 함수와 Optimizer 정의하기</a></li>
<li class="toctree-l4"><a class="reference internal" href="../beginner/blitz/cifar10_tutorial.html#id3">4. 신경망 학습하기</a></li>
<li class="toctree-l4"><a class="reference internal" href="../beginner/blitz/cifar10_tutorial.html#id4">5. 시험용 데이터로 신경망 검사하기</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/blitz/cifar10_tutorial.html#gpu">GPU에서 학습하기</a></li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/blitz/cifar10_tutorial.html#id5">여러개의 GPU에서 학습하기</a></li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/blitz/cifar10_tutorial.html#id6">이제 뭘 해볼까요?</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../beginner/blitz/data_parallel_tutorial.html">Optional: Data Parallelism</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../beginner/blitz/data_parallel_tutorial.html#imports-and-parameters">Imports and parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/blitz/data_parallel_tutorial.html#dummy-dataset">Dummy DataSet</a></li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/blitz/data_parallel_tutorial.html#simple-model">Simple Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/blitz/data_parallel_tutorial.html#create-model-and-dataparallel">Create Model and DataParallel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/blitz/data_parallel_tutorial.html#run-the-model">Run the Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/blitz/data_parallel_tutorial.html#results">Results</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../beginner/blitz/data_parallel_tutorial.html#gpus">2 GPUs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../beginner/blitz/data_parallel_tutorial.html#id1">3 GPUs</a></li>
<li class="toctree-l4"><a class="reference internal" href="../beginner/blitz/data_parallel_tutorial.html#id2">8 GPUs</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/blitz/data_parallel_tutorial.html#summary">Summary</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../beginner/former_torchies_tutorial.html">Torch 사용자를 위한 PyTorch</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../beginner/former_torchies/tensor_tutorial.html">Tensor</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../beginner/former_torchies/tensor_tutorial.html#in-place-out-of-place">In-place / Out-of-place</a></li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/former_torchies/tensor_tutorial.html#zero-indexing">0-인덱스(Zero Indexing)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/former_torchies/tensor_tutorial.html#camel-case">카멜표기법(Camel Case) 없음</a></li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/former_torchies/tensor_tutorial.html#numpy-bridge">NumPy 변환(Bridge)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../beginner/former_torchies/tensor_tutorial.html#torch-tensor-numpy">Torch Tensor를 NumPy 배열로 변환하기</a></li>
<li class="toctree-l4"><a class="reference internal" href="../beginner/former_torchies/tensor_tutorial.html#numpy-torch-tensor">NumPy 배열을 Torch Tensor로 변환하기</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/former_torchies/tensor_tutorial.html#cuda-tensors">CUDA Tensors</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../beginner/former_torchies/autograd_tutorial.html">Autograd</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../beginner/former_torchies/autograd_tutorial.html#history-track-tensor">이력(history)을 추적(track)하는 Tensor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/former_torchies/autograd_tutorial.html#gradient">변화도(Gradient)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../beginner/former_torchies/nn_tutorial.html">nn 패키지</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../beginner/former_torchies/nn_tutorial.html#convnet">예제1: 합성곱 신경망(ConvNet)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/former_torchies/nn_tutorial.html#hook">순방향/역방향 함수 훅(Hook)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/former_torchies/nn_tutorial.html#recurrent-nets">예제2: 순환 신경망(Recurrent Nets)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../beginner/former_torchies/parallelism_tutorial.html">멀티-GPU 예제</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../beginner/former_torchies/parallelism_tutorial.html#dataparallel">DataParallel</a></li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/former_torchies/parallelism_tutorial.html#cpu-gpu">모델의 일부는 CPU, 일부는 GPU에서</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../beginner/pytorch_with_examples.html">예제로 배우는 PyTorch</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../beginner/pytorch_with_examples.html#tensor">Tensor</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../beginner/pytorch_with_examples.html#numpy">준비 운동: NumPy</a></li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/pytorch_with_examples.html#pytorch-tensor">PyTorch: Tensor</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../beginner/pytorch_with_examples.html#autograd">Autograd</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../beginner/pytorch_with_examples.html#pytorch-tensor-autograd">PyTorch: Tensor와 autograd</a></li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/pytorch_with_examples.html#pytorch-autograd">PyTorch: 새 autograd 함수 정의하기</a></li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/pytorch_with_examples.html#tensorflow-static-graph">TensorFlow: 정적 그래프(Static Graph)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../beginner/pytorch_with_examples.html#nn"><cite>nn</cite> 모듈</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../beginner/pytorch_with_examples.html#pytorch-nn">PyTorch: nn</a></li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/pytorch_with_examples.html#pytorch-optim">PyTorch: optim</a></li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/pytorch_with_examples.html#id3">PyTorch: 사용자 정의 nn 모듈</a></li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/pytorch_with_examples.html#pytorch-control-flow-weight-sharing">PyTorch: 제어 흐름(Control Flow) + 가중치 공유(Weight Sharing)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../beginner/pytorch_with_examples.html#examples-download">예제 코드</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../beginner/pytorch_with_examples.html#id5">Tensor</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../beginner/examples_tensor/two_layer_net_numpy.html">준비 운동: NumPy</a></li>
<li class="toctree-l4"><a class="reference internal" href="../beginner/examples_tensor/two_layer_net_tensor.html">PyTorch: Tensor</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/pytorch_with_examples.html#id6">Autograd</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../beginner/examples_autograd/two_layer_net_autograd.html">PyTorch: Tensor와 autograd</a></li>
<li class="toctree-l4"><a class="reference internal" href="../beginner/examples_autograd/two_layer_net_custom_function.html">PyTorch: 새 autograd 함수 정의하기</a></li>
<li class="toctree-l4"><a class="reference internal" href="../beginner/examples_autograd/tf_two_layer_net.html">TensorFlow: 정적 그래프(Static Graph)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/pytorch_with_examples.html#id7"><cite>nn</cite> 모듈</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../beginner/examples_nn/two_layer_net_nn.html">PyTorch: nn</a></li>
<li class="toctree-l4"><a class="reference internal" href="../beginner/examples_nn/two_layer_net_optim.html">PyTorch: optim</a></li>
<li class="toctree-l4"><a class="reference internal" href="../beginner/examples_nn/two_layer_net_module.html">PyTorch: 사용자 정의 nn 모듈</a></li>
<li class="toctree-l4"><a class="reference internal" href="../beginner/examples_nn/dynamic_net.html">PyTorch: 제어 흐름(Control Flow) + 가중치 공유(Weight Sharing)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../beginner/transfer_learning_tutorial.html">전이학습(Transfer Learning) 튜토리얼</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../beginner/transfer_learning_tutorial.html#id2">데이터 불러오기</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../beginner/transfer_learning_tutorial.html#id4">일부 이미지 시각화하기</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../beginner/transfer_learning_tutorial.html#id5">모델 학습하기</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../beginner/transfer_learning_tutorial.html#id6">모델 예측값 시각화하기</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../beginner/transfer_learning_tutorial.html#finetuning">합성곱 신경망 미세조정(Finetuning)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../beginner/transfer_learning_tutorial.html#id7">학습 및 평가하기</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../beginner/transfer_learning_tutorial.html#id8">고정 특정 추출기로써의 합성곱 신경망</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../beginner/transfer_learning_tutorial.html#id9">학습 및 평가하기</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../beginner/data_loading_tutorial.html">Data Loading and Processing Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../beginner/data_loading_tutorial.html#dataset-class">Dataset class</a></li>
<li class="toctree-l2"><a class="reference internal" href="../beginner/data_loading_tutorial.html#transforms">Transforms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../beginner/data_loading_tutorial.html#compose-transforms">Compose transforms</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../beginner/data_loading_tutorial.html#iterating-through-the-dataset">Iterating through the dataset</a></li>
<li class="toctree-l2"><a class="reference internal" href="../beginner/data_loading_tutorial.html#afterword-torchvision">Afterword: torchvision</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../beginner/deep_learning_nlp_tutorial.html">Deep Learning for NLP with Pytorch</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../beginner/nlp/pytorch_tutorial.html">PyTorch 소개</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../beginner/nlp/pytorch_tutorial.html#torch-tensor">Torch의 텐서(Tensor) 라이브러리 소개</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../beginner/nlp/pytorch_tutorial.html#id1">텐서 생성하기</a></li>
<li class="toctree-l4"><a class="reference internal" href="../beginner/nlp/pytorch_tutorial.html#id2">텐서로 작업하기</a></li>
<li class="toctree-l4"><a class="reference internal" href="../beginner/nlp/pytorch_tutorial.html#id3">텐서 재구성</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/nlp/pytorch_tutorial.html#computation-graph-automatic-differentiation">연산 그래프(Computation Graph)와 자동 미분(Automatic Differentiation)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../beginner/nlp/deep_learning_tutorial.html">PyTorch를 이용한 딥러닝</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../beginner/nlp/deep_learning_tutorial.html#affine-maps">딥러닝 블록 구축 : 아핀 맵(affine maps), 비선형성, 객체</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../beginner/nlp/deep_learning_tutorial.html#id1">아핀 맵</a></li>
<li class="toctree-l4"><a class="reference internal" href="../beginner/nlp/deep_learning_tutorial.html#id2">비선형성</a></li>
<li class="toctree-l4"><a class="reference internal" href="../beginner/nlp/deep_learning_tutorial.html#softmax">Softmax 및 확률</a></li>
<li class="toctree-l4"><a class="reference internal" href="../beginner/nlp/deep_learning_tutorial.html#objective-functions">목적 함수(Objective Functions)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/nlp/deep_learning_tutorial.html#id3">최적화와 학습</a></li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/nlp/deep_learning_tutorial.html#id4">Pytorch 에서 네트워크 구성요소 생성하기</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../beginner/nlp/deep_learning_tutorial.html#bag-of-words">예제: 논리 회귀 Bag-of-Words 분류기</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../beginner/nlp/word_embeddings_tutorial.html">Word Embeddings: Encoding Lexical Semantics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../beginner/nlp/word_embeddings_tutorial.html#getting-dense-word-embeddings">Getting Dense Word Embeddings</a></li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/nlp/word_embeddings_tutorial.html#word-embeddings-in-pytorch">Word Embeddings in Pytorch</a></li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/nlp/word_embeddings_tutorial.html#an-example-n-gram-language-modeling">An Example: N-Gram Language Modeling</a></li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/nlp/word_embeddings_tutorial.html#exercise-computing-word-embeddings-continuous-bag-of-words">Exercise: Computing Word Embeddings: Continuous Bag-of-Words</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../beginner/nlp/sequence_models_tutorial.html">Sequence Models and Long-Short Term Memory Networks</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../beginner/nlp/sequence_models_tutorial.html#lstm-s-in-pytorch">LSTM’s in Pytorch</a></li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/nlp/sequence_models_tutorial.html#example-an-lstm-for-part-of-speech-tagging">Example: An LSTM for Part-of-Speech Tagging</a></li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/nlp/sequence_models_tutorial.html#exercise-augmenting-the-lstm-part-of-speech-tagger-with-character-level-features">Exercise: Augmenting the LSTM part-of-speech tagger with character-level features</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../beginner/nlp/advanced_tutorial.html">Advanced: Making Dynamic Decisions and the Bi-LSTM CRF</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../beginner/nlp/advanced_tutorial.html#dynamic-versus-static-deep-learning-toolkits">Dynamic versus Static Deep Learning Toolkits</a></li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/nlp/advanced_tutorial.html#bi-lstm-conditional-random-field-discussion">Bi-LSTM Conditional Random Field Discussion</a></li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/nlp/advanced_tutorial.html#implementation-notes">Implementation Notes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../beginner/nlp/advanced_tutorial.html#exercise-a-new-loss-function-for-discriminative-tagging">Exercise: A new loss function for discriminative tagging</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Intermediate Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../intermediate/char_rnn_classification_tutorial.html">문자-단위 RNN으로 이름 분류하기</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../intermediate/char_rnn_classification_tutorial.html#id2">데이터 준비하기</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../intermediate/char_rnn_classification_tutorial.html#tensor">이름을 Tensor 로 변경</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../intermediate/char_rnn_classification_tutorial.html#id3">네트워크 생성</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intermediate/char_rnn_classification_tutorial.html#id4">학습</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../intermediate/char_rnn_classification_tutorial.html#id5">학습 준비</a></li>
<li class="toctree-l3"><a class="reference internal" href="../intermediate/char_rnn_classification_tutorial.html#id6">네트워크 학습</a></li>
<li class="toctree-l3"><a class="reference internal" href="../intermediate/char_rnn_classification_tutorial.html#id7">결과 도식화</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../intermediate/char_rnn_classification_tutorial.html#id8">결과 평가</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../intermediate/char_rnn_classification_tutorial.html#id9">사용자 입력으로 실행</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../intermediate/char_rnn_classification_tutorial.html#id10">연습</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../intermediate/char_rnn_generation_tutorial.html">문자-단위 RNN으로 이름 생성하기</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../intermediate/char_rnn_generation_tutorial.html#id2">데이터 준비하기</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intermediate/char_rnn_generation_tutorial.html#id4">네트워크 생성</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intermediate/char_rnn_generation_tutorial.html#id5">학습</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../intermediate/char_rnn_generation_tutorial.html#id6">학습 준비</a></li>
<li class="toctree-l3"><a class="reference internal" href="../intermediate/char_rnn_generation_tutorial.html#id7">네트워크 학습</a></li>
<li class="toctree-l3"><a class="reference internal" href="../intermediate/char_rnn_generation_tutorial.html#id8">손실 도식화</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../intermediate/char_rnn_generation_tutorial.html#id9">네트워크 샘플링</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intermediate/char_rnn_generation_tutorial.html#exercises">Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../intermediate/seq2seq_translation_tutorial.html">Sequence to Sequence 네트워크와 Attention을 이용한 번역</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../intermediate/seq2seq_translation_tutorial.html#id2">데이터 파일 로딩</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intermediate/seq2seq_translation_tutorial.html#seq2seq">Seq2Seq 모델</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../intermediate/seq2seq_translation_tutorial.html#id4">인코더</a></li>
<li class="toctree-l3"><a class="reference internal" href="../intermediate/seq2seq_translation_tutorial.html#id5">디코더</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../intermediate/seq2seq_translation_tutorial.html#id6">간단한 디코더</a></li>
<li class="toctree-l4"><a class="reference internal" href="../intermediate/seq2seq_translation_tutorial.html#id7">어텐션 디코더</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../intermediate/seq2seq_translation_tutorial.html#id8">학습</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../intermediate/seq2seq_translation_tutorial.html#id9">학습 데이터 준비</a></li>
<li class="toctree-l3"><a class="reference internal" href="../intermediate/seq2seq_translation_tutorial.html#id10">모델 학습</a></li>
<li class="toctree-l3"><a class="reference internal" href="../intermediate/seq2seq_translation_tutorial.html#id11">결과 도식화</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../intermediate/seq2seq_translation_tutorial.html#id12">평가</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intermediate/seq2seq_translation_tutorial.html#id13">학습과 평가</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../intermediate/seq2seq_translation_tutorial.html#id14">어텐션 시각화</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../intermediate/seq2seq_translation_tutorial.html#id15">연습</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../intermediate/reinforcement_q_learning.html">강화 학습 (DQN) 튜토리얼</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../intermediate/reinforcement_q_learning.html#replay-memory">재현 메모리(Replay Memory)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intermediate/reinforcement_q_learning.html#id2">DQN 알고리즘</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../intermediate/reinforcement_q_learning.html#q">Q-네트워크</a></li>
<li class="toctree-l3"><a class="reference internal" href="../intermediate/reinforcement_q_learning.html#id3">입력 추출</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../intermediate/reinforcement_q_learning.html#id4">학습</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../intermediate/reinforcement_q_learning.html#id5">하이퍼 파라미터와 유틸리티</a></li>
<li class="toctree-l3"><a class="reference internal" href="../intermediate/reinforcement_q_learning.html#id8">학습 루프</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../intermediate/dist_tuto.html">Pytorch로 분산 어플리케이션 개발하기</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../intermediate/dist_tuto.html#setup">Setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intermediate/dist_tuto.html#point-to-point-communication">지점간 통신(Point-to-Point Communication)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intermediate/dist_tuto.html#collective-communication">집단 통신 (Collective Communication)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intermediate/dist_tuto.html#distributed-training">분산 학습(Distributed Training)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../intermediate/dist_tuto.html#our-own-ring-allreduce">Our Own Ring-Allreduce</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../intermediate/dist_tuto.html#advanced-topics">Advanced Topics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../intermediate/dist_tuto.html#id2">통신 백엔드</a></li>
<li class="toctree-l3"><a class="reference internal" href="../intermediate/dist_tuto.html#id3">초기화 방법</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../intermediate/spatial_transformer_tutorial.html">공간 변형기 네트워크(Spatial Transformer Networks) 튜토리얼</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../intermediate/spatial_transformer_tutorial.html#id2">데이터 로딩</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intermediate/spatial_transformer_tutorial.html#id3">공간 변형 네트워크 설명</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intermediate/spatial_transformer_tutorial.html#id4">모델 학습</a></li>
<li class="toctree-l2"><a class="reference internal" href="../intermediate/spatial_transformer_tutorial.html#stn">STN 결과 시각화</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Advanced Tutorials</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="neural_style_tutorial.html">PyTorch를 이용한 신경망-변환(Neural-Transfer)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="neural_style_tutorial.html#id2">소개</a><ul>
<li class="toctree-l3"><a class="reference internal" href="neural_style_tutorial.html#id3">신경망 뭐라고?</a></li>
<li class="toctree-l3"><a class="reference internal" href="neural_style_tutorial.html#id4">어떻게 동작합니까?</a><ul>
<li class="toctree-l4"><a class="reference internal" href="neural_style_tutorial.html#id5">그래서. 어떻게 동작하냐고요?</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="neural_style_tutorial.html#pytorch">PyTorch 구현</a><ul>
<li class="toctree-l3"><a class="reference internal" href="neural_style_tutorial.html#id6">패키지들</a></li>
<li class="toctree-l3"><a class="reference internal" href="neural_style_tutorial.html#cuda">쿠다(CUDA)</a></li>
<li class="toctree-l3"><a class="reference internal" href="neural_style_tutorial.html#id7">이미지 읽기</a></li>
<li class="toctree-l3"><a class="reference internal" href="neural_style_tutorial.html#id8">이미지 표시하기</a></li>
<li class="toctree-l3"><a class="reference internal" href="neural_style_tutorial.html#id9">콘텐츠 로스</a></li>
<li class="toctree-l3"><a class="reference internal" href="neural_style_tutorial.html#id10">스타일 로스</a></li>
<li class="toctree-l3"><a class="reference internal" href="neural_style_tutorial.html#id15">뉴럴 네트워크 읽기</a></li>
<li class="toctree-l3"><a class="reference internal" href="neural_style_tutorial.html#id16">입력 이미지</a></li>
<li class="toctree-l3"><a class="reference internal" href="neural_style_tutorial.html#id17">경사 하강법</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="numpy_extensions_tutorial.html">Creating extensions using numpy and scipy</a><ul>
<li class="toctree-l2"><a class="reference internal" href="numpy_extensions_tutorial.html#parameter-less-example">Parameter-less example</a></li>
<li class="toctree-l2"><a class="reference internal" href="numpy_extensions_tutorial.html#parametrized-example">Parametrized example</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="super_resolution_with_caffe2.html">Transfering a model from PyTorch to Caffe2 and Mobile using ONNX</a><ul>
<li class="toctree-l2"><a class="reference internal" href="super_resolution_with_caffe2.html#transfering-srresnet-using-onnx">Transfering SRResNet using ONNX</a></li>
<li class="toctree-l2"><a class="reference internal" href="super_resolution_with_caffe2.html#running-the-model-on-mobile-devices">Running the model on mobile devices</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Custom C++ and CUDA Extensions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#motivation-and-example">Motivation and Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="#writing-a-c-extension">Writing a C++ Extension</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#building-with-setuptools">Building with <code class="docutils literal notranslate"><span class="pre">setuptools</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#writing-the-c-op">Writing the C++ Op</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#forward-pass">Forward Pass</a></li>
<li class="toctree-l4"><a class="reference internal" href="#backward-pass">Backward Pass</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#binding-to-python">Binding to Python</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-your-extension">Using Your Extension</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#performance-comparison">Performance Comparison</a></li>
<li class="toctree-l4"><a class="reference internal" href="#performance-on-gpu-devices">Performance on GPU Devices</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#jit-compiling-extensions">JIT Compiling Extensions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#writing-a-mixed-c-cuda-extension">Writing a Mixed C++/CUDA extension</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#integrating-a-c-cuda-operation-with-pytorch">Integrating a C++/CUDA Operation with PyTorch</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id2">Performance Comparison</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#conclusion">Conclusion</a></li>
</ul>
</li>
</ul>



        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">


      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">

          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">PyTorch Tutorials</a>

      </nav>



      <div class="wy-nav-content">
        <div class="rst-content">
















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">

      <li><a href="../index.html">Docs</a> &raquo;</li>

      <li>Custom C++ and CUDA Extensions</li>


      <li class="wy-breadcrumbs-aside">


            <a href="../_sources/advanced/cpp_extension.rst.txt" rel="nofollow"> View page source</a>


      </li>

  </ul>


  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">

  <div class="section" id="custom-c-and-cuda-extensions">
<h1>Custom C++ and CUDA Extensions<a class="headerlink" href="#custom-c-and-cuda-extensions" title="Permalink to this headline">¶</a></h1>
<p><strong>Author</strong>: <a class="reference external" href="http://goldsborough.me">Peter Goldsborough</a></p>
<p>PyTorch provides a plethora of operations related to neural networks, arbitrary
tensor algebra, data wrangling and other purposes. However, you may still find
yourself in need of a more customized operation. For example, you might want to
use a novel activation function you found in a paper, or implement an operation
you developed as part of your research.</p>
<p>The easiest way of integrating such a custom operation in PyTorch is to write it
in Python by extending <code class="xref py py-class docutils literal notranslate"><span class="pre">Function</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">Module</span></code> as outlined <a class="reference external" href="http://pytorch.org/docs/master/notes/extending.html">here</a>. This gives you the full
power of automatic differentiation (spares you from writing derivative
functions) as well as the usual expressiveness of Python. However, there may be
times when your operation is better implemented in C++. For example, your code
may need to be <em>really</em> fast because it is called very frequently in your model
or is very expensive even for few calls. Another plausible reason is that it
depends on or interacts with other C or C++ libraries. To address such cases,
PyTorch provides a very easy way of writing custom <em>C++ extensions</em>.</p>
<p>C++ extensions are a mechanism we have developed to allow users (you) to create
PyTorch operators defined <em>out-of-source</em>, i.e. separate from the PyTorch
backend. This approach is <em>different</em> from the way native PyTorch operations are
implemented. C++ extensions are intended to spare you much of the boilerplate
associated with integrating an operation with PyTorch’s backend while providing
you with a high degree of flexibility for your PyTorch-based projects.
Nevertheless, once you have defined your operation as a C++ extension, turning
it into a native PyTorch function is largely a matter of code organization,
which you can tackle after the fact if you decide to contribute your operation
upstream.</p>
<div class="section" id="motivation-and-example">
<h2>Motivation and Example<a class="headerlink" href="#motivation-and-example" title="Permalink to this headline">¶</a></h2>
<p>The rest of this note will walk through a practical example of writing and using
a C++ (and CUDA) extension. If you are being chased or someone will fire you if
you don’t get that op done by the end of the day, you can skip this section and
head straight to the implementation details in the next section.</p>
<p>Let’s say you’ve come up with a new kind of recurrent unit that you found to
have superior properties compared to the state of the art. This recurrent unit
is similar to an LSTM, but differs in that it lacks a <em>forget gate</em> and uses an
<em>Exponential Linear Unit</em> (ELU) as its internal activation function. Because
this unit never forgets, we’ll call it <em>LLTM</em>, or <em>Long-Long-Term-Memory</em> unit.</p>
<p>The two ways in which LLTMs differ from vanilla LSTMs are significant enough
that we can’t configure PyTorch’s <code class="docutils literal notranslate"><span class="pre">LSTMCell</span></code> for our purposes, so we’ll have to
create a custom cell. The first and easiest approach for this – and likely in
all cases a good first step – is to implement our desired functionality in
plain PyTorch with Python. For this, we need to subclass
<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.nn.Module</span></code> and implement the forward pass of the LLTM. This would
look something like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">LLTM</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_features</span><span class="p">,</span> <span class="n">state_size</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LLTM</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_features</span> <span class="o">=</span> <span class="n">input_features</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_size</span> <span class="o">=</span> <span class="n">state_size</span>
        <span class="c1"># 3 * state_size for input gate, output gate and candidate cell gate.</span>
        <span class="c1"># input_features + state_size because we will multiply with [input, h].</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">state_size</span><span class="p">,</span> <span class="n">input_features</span> <span class="o">+</span> <span class="n">state_size</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bias</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">state_size</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_parameters</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">reset_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">stdv</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_size</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">weight</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">():</span>
            <span class="n">weight</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">uniform_</span><span class="p">(</span><span class="o">-</span><span class="n">stdv</span><span class="p">,</span> <span class="o">+</span><span class="n">stdv</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">old_h</span><span class="p">,</span> <span class="n">old_cell</span> <span class="o">=</span> <span class="n">state</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">old_h</span><span class="p">,</span> <span class="nb">input</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Compute the input, output and candidate cell gates with one MM.</span>
        <span class="n">gate_weights</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">linear</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias</span><span class="p">)</span>
        <span class="c1"># Split the combined gate weight matrix into its components.</span>
        <span class="n">gates</span> <span class="o">=</span> <span class="n">gate_weights</span><span class="o">.</span><span class="n">chunk</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">input_gate</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">gates</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">output_gate</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">gates</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># Here we use an ELU instead of the usual tanh.</span>
        <span class="n">candidate_cell</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">elu</span><span class="p">(</span><span class="n">gates</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="c1"># Compute the new cell state.</span>
        <span class="n">new_cell</span> <span class="o">=</span> <span class="n">old_cell</span> <span class="o">+</span> <span class="n">candidate_cell</span> <span class="o">*</span> <span class="n">input_gate</span>
        <span class="c1"># Compute the new hidden state and output.</span>
        <span class="n">new_h</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">new_cell</span><span class="p">)</span> <span class="o">*</span> <span class="n">output_gate</span>

        <span class="k">return</span> <span class="n">new_h</span><span class="p">,</span> <span class="n">new_cell</span>
</pre></div>
</div>
<p>which we could then use as expected:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">torch</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">input_features</span><span class="p">)</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">state_size</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">state_size</span><span class="p">)</span>

<span class="n">rnn</span> <span class="o">=</span> <span class="n">LLTM</span><span class="p">(</span><span class="n">input_features</span><span class="p">,</span> <span class="n">state_size</span><span class="p">)</span>

<span class="n">new_h</span><span class="p">,</span> <span class="n">new_C</span> <span class="o">=</span> <span class="n">rnn</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
</pre></div>
</div>
<p>Naturally, if at all possible and plausible, you should use this approach to
extend PyTorch. Since PyTorch has highly optimized implementations of its
operations for CPU <em>and</em> GPU, powered by libraries such as <a class="reference external" href="https://developer.nvidia.com/cudnn">NVIDIA cuDNN</a>, <a class="reference external" href="https://software.intel.com/en-us/mkl">Intel MKL</a> or <a class="reference external" href="https://github.com/Maratyszcza/NNPACK">NNPACK</a>, PyTorch code like above will often be
fast enough. However, we can also see why, under certain circumstances, there is
room for further performance improvements. The most obvious reason is that
PyTorch has no knowledge of the <em>algorithm</em> you are implementing. It knows only
of the individual operations you use to compose your algorithm. As such, PyTorch
must execute your operations individually, one after the other. Since each
individual call to the implementation (or <em>kernel</em>) of an operation, which may
involve launch of a CUDA kernel, has a certain amount of overhead, this overhead
may become significant across many function calls. Furthermore, the Python
interpreter that is running our code can itself slow down our program.</p>
<p>A definite method of speeding things up is therefore to rewrite parts in C++ (or
CUDA) and <em>fuse</em> particular groups of operations. Fusing means combining the
implementations of many functions into a single functions, which profits from
fewer kernel launches as well as other optimizations we can perform with
increased visibility of the global flow of data.</p>
<p>Let’s see how we can use C++ extensions to implement a <em>fused</em> version of the
LLTM. We’ll begin by writing it in plain C++, using the <a class="reference external" href="https://github.com/zdevito/ATen">ATen</a> library that powers much of PyTorch’s
backend, and see how easily it lets us translate our Python code. We’ll then
speed things up even more by moving parts of the model to CUDA kernel to benefit
from the massive parallelism GPUs provide.</p>
</div>
<div class="section" id="writing-a-c-extension">
<h2>Writing a C++ Extension<a class="headerlink" href="#writing-a-c-extension" title="Permalink to this headline">¶</a></h2>
<p>C++ extensions come in two flavors: They can be built “ahead of time” with
<code class="xref py py-mod docutils literal notranslate"><span class="pre">setuptools</span></code>, or “just in time” via
<code class="xref py py-func docutils literal notranslate"><span class="pre">torch.utils.cpp_extension.load()</span></code>. We’ll begin with the first approach and
discuss the latter later.</p>
<div class="section" id="building-with-setuptools">
<h3>Building with <code class="xref py py-mod docutils literal notranslate"><span class="pre">setuptools</span></code><a class="headerlink" href="#building-with-setuptools" title="Permalink to this headline">¶</a></h3>
<p>For the “ahead of time” flavor, we build our C++ extension by writing a
<code class="docutils literal notranslate"><span class="pre">setup.py</span></code> script that uses setuptools to compile our C++ code. For the LLTM, it
looks as simple as this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">setuptools</span> <span class="k">import</span> <span class="n">setup</span>
<span class="kn">from</span> <span class="nn">torch.utils.cpp_extension</span> <span class="k">import</span> <span class="n">CppExtension</span><span class="p">,</span> <span class="n">BuildExtension</span>

<span class="n">setup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;lltm&#39;</span><span class="p">,</span>
      <span class="n">ext_modules</span><span class="o">=</span><span class="p">[</span><span class="n">CppExtension</span><span class="p">(</span><span class="s1">&#39;lltm&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;lltm.cpp&#39;</span><span class="p">])]</span>
      <span class="n">cmdclass</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;build_ext&#39;</span><span class="p">:</span> <span class="n">BuildExtension</span><span class="p">})</span>
</pre></div>
</div>
<p>In this code, :class:<code class="docutils literal notranslate"><span class="pre">CppExtension</span></code> is a convenience wrapper around
<code class="xref py py-class docutils literal notranslate"><span class="pre">setuptools.Extension</span></code> that passes the correct include paths and sets
the language of the extension to C++. The equivalent vanilla <code class="xref py py-mod docutils literal notranslate"><span class="pre">setuptools</span></code>
code would simply be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">setuptools</span><span class="o">.</span><span class="n">Extension</span><span class="p">(</span>
   <span class="n">name</span><span class="o">=</span><span class="s1">&#39;lltm&#39;</span><span class="p">,</span>
   <span class="n">sources</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;lltm.cpp&#39;</span><span class="p">],</span>
   <span class="n">include_dirs</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">cpp_extension</span><span class="o">.</span><span class="n">include_paths</span><span class="p">(),</span>
   <span class="n">language</span><span class="o">=</span><span class="s1">&#39;c++&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">BuildExtension</span></code> performs a number of required configuration steps and
checks and also manages mixed compilation in the case of mixed C++/CUDA
extensions. And that’s all we really need to know about building C++ extensions
for now! Let’s now take a look at the implementation of our C++ extension,
which goes into <code class="docutils literal notranslate"><span class="pre">lltm.cpp</span></code>.</p>
</div>
<div class="section" id="writing-the-c-op">
<h3>Writing the C++ Op<a class="headerlink" href="#writing-the-c-op" title="Permalink to this headline">¶</a></h3>
<p>Let’s start implementing the LLTM in C++! One function we’ll need for the
backward pass is the derivative of the sigmoid. This is a small enough piece of
code to discuss the overall environment that is available to us when writing C++
extensions:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;torch/torch.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">d_sigmoid</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">z</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">s</span> <span class="o">=</span> <span class="n">at</span><span class="o">::</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">&lt;torch/torch.h&gt;</span></code> is the one-stop header to include all the necessary PyTorch
bits to write C++ extensions. It includes:</p>
<ul class="simple">
<li>The ATen library, which is our primary API for tensor computation,</li>
<li><a class="reference external" href="https://github.com/pybind/pybind11">pybind11</a>, which is how we create Python bindings for our C++ code,</li>
<li>Headers that manage the details of interaction between ATen and pybind11.</li>
</ul>
<p>The implementation of <code class="xref py py-func docutils literal notranslate"><span class="pre">d_sigmoid()</span></code> shows how to use the ATen API.
PyTorch’s tensor and variable interface is generated automatically from the
ATen library, so we can more or less translate our Python implementation 1:1
into C++. Our primary datatype for all computations will be
<code class="xref py py-class docutils literal notranslate"><span class="pre">at::Tensor</span></code>. Its full API can be inspected <a class="reference external" href="https://github.com/pytorch/pytorch/blob/master/aten/doc/Tensor.h">here</a>. Notice
also that we can include <code class="docutils literal notranslate"><span class="pre">&lt;iostream&gt;</span></code> or <em>any other C or C++ header</em> – we have
the full power of C++11 at our disposal.</p>
<div class="section" id="forward-pass">
<h4>Forward Pass<a class="headerlink" href="#forward-pass" title="Permalink to this headline">¶</a></h4>
<p>Next we can port our entire forward pass to C++:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">at</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">lltm_forward</span><span class="p">(</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">input</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">weights</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">bias</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">old_h</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">old_cell</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">X</span> <span class="o">=</span> <span class="n">at</span><span class="o">::</span><span class="n">cat</span><span class="p">({</span><span class="n">old_h</span><span class="p">,</span> <span class="n">input</span><span class="p">},</span> <span class="cm">/*dim=*/</span><span class="mi">1</span><span class="p">);</span>

  <span class="k">auto</span> <span class="n">gate_weights</span> <span class="o">=</span> <span class="n">at</span><span class="o">::</span><span class="n">addmm</span><span class="p">(</span><span class="n">bias</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">weights</span><span class="p">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
  <span class="k">auto</span> <span class="n">gates</span> <span class="o">=</span> <span class="n">gate_weights</span><span class="p">.</span><span class="n">chunk</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="cm">/*dim=*/</span><span class="mi">1</span><span class="p">);</span>

  <span class="k">auto</span> <span class="n">input_gate</span> <span class="o">=</span> <span class="n">at</span><span class="o">::</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">gates</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="k">auto</span> <span class="n">output_gate</span> <span class="o">=</span> <span class="n">at</span><span class="o">::</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">gates</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="k">auto</span> <span class="n">candidate_cell</span> <span class="o">=</span> <span class="n">at</span><span class="o">::</span><span class="n">elu</span><span class="p">(</span><span class="n">gates</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="cm">/*alpha=*/</span><span class="mf">1.0</span><span class="p">);</span>

  <span class="k">auto</span> <span class="n">new_cell</span> <span class="o">=</span> <span class="n">old_cell</span> <span class="o">+</span> <span class="n">candidate_cell</span> <span class="o">*</span> <span class="n">input_gate</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">new_h</span> <span class="o">=</span> <span class="n">at</span><span class="o">::</span><span class="n">tanh</span><span class="p">(</span><span class="n">new_cell</span><span class="p">)</span> <span class="o">*</span> <span class="n">output_gate</span><span class="p">;</span>

  <span class="k">return</span> <span class="p">{</span><span class="n">new_h</span><span class="p">,</span>
          <span class="n">new_cell</span><span class="p">,</span>
          <span class="n">input_gate</span><span class="p">,</span>
          <span class="n">output_gate</span><span class="p">,</span>
          <span class="n">candidate_cell</span><span class="p">,</span>
          <span class="n">X</span><span class="p">,</span>
          <span class="n">gate_weights</span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="backward-pass">
<h4>Backward Pass<a class="headerlink" href="#backward-pass" title="Permalink to this headline">¶</a></h4>
<p>At this time, PyTorch’s C++ interface does not support automatic
differentiation. This is something the PyTorch team is working on, but it is
not available yet. As such, we have to also implement the backward pass of our
LLTM, which computes the derivative of the loss with respect to each input of
the forward pass. Ultimately, we will plop both the forward and backward
function into a <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.nn.Function</span></code> to create a nice Python binding. The
backward function is slightly more involved, so we’ll not dig deeper into the
code (if you are interested, <a class="reference external" href="http://www.cs.toronto.edu/~graves/phd.pdf">Alex Graves’ thesis</a> is a good read for more
information on this):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// tanh&#39;(z) = 1 - tanh^2(z)</span>
<span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">d_tanh</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">z</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">z</span><span class="p">.</span><span class="n">tanh</span><span class="p">().</span><span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// elu&#39;(z) = relu&#39;(z) + { alpha * exp(z) if (alpha * (exp(z) - 1)) &lt; 0, else 0}</span>
<span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">d_elu</span><span class="p">(</span><span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">z</span><span class="p">,</span> <span class="n">at</span><span class="o">::</span><span class="n">Scalar</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">e</span> <span class="o">=</span> <span class="n">z</span><span class="p">.</span><span class="n">exp</span><span class="p">();</span>
  <span class="k">auto</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="p">(</span><span class="n">e</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">z</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">).</span><span class="n">type_as</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="n">mask</span><span class="p">.</span><span class="n">type_as</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">e</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">at</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">lltm_backward</span><span class="p">(</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">grad_h</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">grad_cell</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">new_cell</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">input_gate</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">output_gate</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">candidate_cell</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">X</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">gate_weights</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">weights</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">d_output_gate</span> <span class="o">=</span> <span class="n">at</span><span class="o">::</span><span class="n">tanh</span><span class="p">(</span><span class="n">new_cell</span><span class="p">)</span> <span class="o">*</span> <span class="n">grad_h</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">d_tanh_new_cell</span> <span class="o">=</span> <span class="n">output_gate</span> <span class="o">*</span> <span class="n">grad_h</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">d_new_cell</span> <span class="o">=</span> <span class="n">d_tanh</span><span class="p">(</span><span class="n">new_cell</span><span class="p">)</span> <span class="o">*</span> <span class="n">d_tanh_new_cell</span> <span class="o">+</span> <span class="n">grad_cell</span><span class="p">;</span>

  <span class="k">auto</span> <span class="n">d_old_cell</span> <span class="o">=</span> <span class="n">d_new_cell</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">d_candidate_cell</span> <span class="o">=</span> <span class="n">input_gate</span> <span class="o">*</span> <span class="n">d_new_cell</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">d_input_gate</span> <span class="o">=</span> <span class="n">candidate_cell</span> <span class="o">*</span> <span class="n">d_new_cell</span><span class="p">;</span>

  <span class="k">auto</span> <span class="n">gates</span> <span class="o">=</span> <span class="n">gate_weights</span><span class="p">.</span><span class="n">chunk</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="cm">/*dim=*/</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">d_input_gate</span> <span class="o">*=</span> <span class="n">d_sigmoid</span><span class="p">(</span><span class="n">gates</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="n">d_output_gate</span> <span class="o">*=</span> <span class="n">d_sigmoid</span><span class="p">(</span><span class="n">gates</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="n">d_candidate_cell</span> <span class="o">*=</span> <span class="n">d_elu</span><span class="p">(</span><span class="n">gates</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

  <span class="k">auto</span> <span class="n">d_gates</span> <span class="o">=</span>
      <span class="n">at</span><span class="o">::</span><span class="n">cat</span><span class="p">({</span><span class="n">d_input_gate</span><span class="p">,</span> <span class="n">d_output_gate</span><span class="p">,</span> <span class="n">d_candidate_cell</span><span class="p">},</span> <span class="cm">/*dim=*/</span><span class="mi">1</span><span class="p">);</span>

  <span class="k">auto</span> <span class="n">d_weights</span> <span class="o">=</span> <span class="n">d_gates</span><span class="p">.</span><span class="n">t</span><span class="p">().</span><span class="n">mm</span><span class="p">(</span><span class="n">X</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">d_bias</span> <span class="o">=</span> <span class="n">d_gates</span><span class="p">.</span><span class="n">sum</span><span class="p">(</span><span class="cm">/*dim=*/</span><span class="mi">0</span><span class="p">,</span> <span class="cm">/*keepdim=*/</span><span class="nb">true</span><span class="p">);</span>

  <span class="k">auto</span> <span class="n">d_X</span> <span class="o">=</span> <span class="n">d_gates</span><span class="p">.</span><span class="n">mm</span><span class="p">(</span><span class="n">weights</span><span class="p">);</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">state_size</span> <span class="o">=</span> <span class="n">grad_h</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">d_old_h</span> <span class="o">=</span> <span class="n">d_X</span><span class="p">.</span><span class="n">slice</span><span class="p">(</span><span class="cm">/*dim=*/</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">state_size</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">d_input</span> <span class="o">=</span> <span class="n">d_X</span><span class="p">.</span><span class="n">slice</span><span class="p">(</span><span class="cm">/*dim=*/</span><span class="mi">1</span><span class="p">,</span> <span class="n">state_size</span><span class="p">);</span>

  <span class="k">return</span> <span class="p">{</span><span class="n">d_old_h</span><span class="p">,</span> <span class="n">d_input</span><span class="p">,</span> <span class="n">d_weights</span><span class="p">,</span> <span class="n">d_bias</span><span class="p">,</span> <span class="n">d_old_cell</span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="binding-to-python">
<h3>Binding to Python<a class="headerlink" href="#binding-to-python" title="Permalink to this headline">¶</a></h3>
<p>Once you have your operation written in C++ and ATen, you can use pybind11 to
bind your C++ functions or classes into Python in a very simple manner.
Questions or issues you have about this part of PyTorch C++ extensions will
largely be addressed by <a class="reference external" href="http://pybind11.readthedocs.io/en/master/">pybind11 documentation</a>.</p>
<p>For our extensions, the necessary binding code spans only four lines:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">PYBIND11_MODULE</span><span class="p">(</span><span class="n">TORCH_EXTENSION_NAME</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;forward&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lltm_forward</span><span class="p">,</span> <span class="s">&quot;LLTM forward&quot;</span><span class="p">);</span>
  <span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;backward&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lltm_backward</span><span class="p">,</span> <span class="s">&quot;LLTM backward&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>One bit to note here is the macro <code class="docutils literal notranslate"><span class="pre">TORCH_EXTENSION_NAME</span></code>. The torch extension
build will define it as the name you give your extension in the <code class="docutils literal notranslate"><span class="pre">setup.py</span></code>
script. In this case, the value of <code class="docutils literal notranslate"><span class="pre">TORCH_EXTENSION_NAME</span></code> would be “lltm”.
This is to avoid having to maintain the name of the extension in two places
(the build script and your C++ code), as a mismatch between the two can lead to
nasty and hard to track issues.</p>
</div>
<div class="section" id="using-your-extension">
<h3>Using Your Extension<a class="headerlink" href="#using-your-extension" title="Permalink to this headline">¶</a></h3>
<p>We are now set to import our extension in PyTorch. At this point, your directory
structure could look something like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pytorch</span><span class="o">/</span>
  <span class="n">lltm</span><span class="o">-</span><span class="n">extension</span><span class="o">/</span>
    <span class="n">lltm</span><span class="o">.</span><span class="n">cpp</span>
    <span class="n">setup</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>Now, run <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">install</span></code> to build and install your extension. This
should look something like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>running install
running bdist_egg
running egg_info
writing lltm.egg-info/PKG-INFO
writing dependency_links to lltm.egg-info/dependency_links.txt
writing top-level names to lltm.egg-info/top_level.txt
reading manifest file &#39;lltm.egg-info/SOURCES.txt&#39;
writing manifest file &#39;lltm.egg-info/SOURCES.txt&#39;
installing library code to build/bdist.linux-x86_64/egg
running install_lib
running build_ext
building &#39;lltm&#39; extension
gcc -Wsign-compare -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -fPIC -I~/local/miniconda/lib/python3.6/site-packages/torch/lib/include -I~/local/miniconda/lib/python3.6/site-packages/torch/lib/include/TH -I~/local/miniconda/lib/python3.6/site-packages/torch/lib/include/THC -I~/local/miniconda/include/python3.6m -c lltm.cpp -o build/temp.linux-x86_64-3.6/lltm.o -DTORCH_EXTENSION_NAME=lltm -std=c++11
cc1plus: warning: command line option ‘-Wstrict-prototypes’ is valid for C/ObjC but not for C++
g++ -pthread -shared -B ~/local/miniconda/compiler_compat -L~/local/miniconda/lib -Wl,-rpath=~/local/miniconda/lib -Wl,--no-as-needed -Wl,--sysroot=/ build/temp.linux-x86_64-3.6/lltm.o -o build/lib.linux-x86_64-3.6/lltm.cpython-36m-x86_64-linux-gnu.so
creating build/bdist.linux-x86_64/egg
copying build/lib.linux-x86_64-3.6/lltm_cuda.cpython-36m-x86_64-linux-gnu.so -&gt; build/bdist.linux-x86_64/egg
copying build/lib.linux-x86_64-3.6/lltm.cpython-36m-x86_64-linux-gnu.so -&gt; build/bdist.linux-x86_64/egg
creating stub loader for lltm.cpython-36m-x86_64-linux-gnu.so
byte-compiling build/bdist.linux-x86_64/egg/lltm.py to lltm.cpython-36.pyc
creating build/bdist.linux-x86_64/egg/EGG-INFO
copying lltm.egg-info/PKG-INFO -&gt; build/bdist.linux-x86_64/egg/EGG-INFO
copying lltm.egg-info/SOURCES.txt -&gt; build/bdist.linux-x86_64/egg/EGG-INFO
copying lltm.egg-info/dependency_links.txt -&gt; build/bdist.linux-x86_64/egg/EGG-INFO
copying lltm.egg-info/top_level.txt -&gt; build/bdist.linux-x86_64/egg/EGG-INFO
writing build/bdist.linux-x86_64/egg/EGG-INFO/native_libs.txt
zip_safe flag not set; analyzing archive contents...
__pycache__.lltm.cpython-36: module references __file__
creating &#39;dist/lltm-0.0.0-py3.6-linux-x86_64.egg&#39; and adding &#39;build/bdist.linux-x86_64/egg&#39; to it
removing &#39;build/bdist.linux-x86_64/egg&#39; (and everything under it)
Processing lltm-0.0.0-py3.6-linux-x86_64.egg
removing &#39;~/local/miniconda/lib/python3.6/site-packages/lltm-0.0.0-py3.6-linux-x86_64.egg&#39; (and everything under it)
creating ~/local/miniconda/lib/python3.6/site-packages/lltm-0.0.0-py3.6-linux-x86_64.egg
Extracting lltm-0.0.0-py3.6-linux-x86_64.egg to ~/local/miniconda/lib/python3.6/site-packages
lltm 0.0.0 is already the active version in easy-install.pth

Installed ~/local/miniconda/lib/python3.6/site-packages/lltm-0.0.0-py3.6-linux-x86_64.egg
Processing dependencies for lltm==0.0.0
Finished processing dependencies for lltm==0.0.0
</pre></div>
</div>
<p>A small note on compilers: Due to ABI versioning issues, the compiler you use to
build your C++ extension must be <em>ABI-compatible</em> with the compiler PyTorch was
built with. In practice, this means that you must use GCC version 4.9 and above on Linux.
For Ubuntu 16.04 and other more-recent Linux distributions, this should be the
default compiler already. On MacOS, you must use clang (which does not have any ABI versioning issues). In the worst
case, you can build PyTorch from source with your compiler and then build the
extension with that same compiler.</p>
<p>Once your extension is built, you can simply import it in Python, using the
name you specified in your <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> script. Just be sure to <code class="docutils literal notranslate"><span class="pre">import</span>
<span class="pre">torch</span></code> first, as this will resolve some symbols that the dynamic linker must
see:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="kn">import</span> <span class="nn">torch</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="kn">import</span> <span class="nn">lltm</span>
<span class="n">In</span> <span class="p">[</span><span class="mi">3</span><span class="p">]:</span> <span class="n">lltm</span><span class="o">.</span><span class="n">forward</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span> <span class="o">&lt;</span><span class="n">function</span> <span class="n">lltm</span><span class="o">.</span><span class="n">PyCapsule</span><span class="o">.</span><span class="n">forward</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>If we call <code class="docutils literal notranslate"><span class="pre">help()</span></code> on the function or module, we can see that its signature
matches our C++ code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">In</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="n">help</span><span class="p">(</span><span class="n">lltm</span><span class="o">.</span><span class="n">forward</span><span class="p">)</span>
<span class="n">forward</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="n">method</span> <span class="n">of</span> <span class="n">builtins</span><span class="o">.</span><span class="n">PyCapsule</span> <span class="n">instance</span>
    <span class="n">forward</span><span class="p">(</span><span class="n">arg0</span><span class="p">:</span> <span class="n">at</span><span class="p">::</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">arg1</span><span class="p">:</span> <span class="n">at</span><span class="p">::</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">arg2</span><span class="p">:</span> <span class="n">at</span><span class="p">::</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">arg3</span><span class="p">:</span> <span class="n">at</span><span class="p">::</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">arg4</span><span class="p">:</span> <span class="n">at</span><span class="p">::</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">at</span><span class="p">::</span><span class="n">Tensor</span><span class="p">]</span>

    <span class="n">LLTM</span> <span class="n">forward</span>
</pre></div>
</div>
<p>Since we are now able to call our C++ functions from Python, we can wrap them
with <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.nn.Function</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.nn.Module</span></code> to make them first
class citizens of PyTorch:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">torch</span>

<span class="c1"># Our module!</span>
<span class="kn">import</span> <span class="nn">lltm</span>

<span class="k">class</span> <span class="nc">LLTMFunction</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Function</span><span class="p">):</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">old_h</span><span class="p">,</span> <span class="n">old_cell</span><span class="p">):</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="n">lltm</span><span class="o">.</span><span class="n">forward</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">old_h</span><span class="p">,</span> <span class="n">old_cell</span><span class="p">)</span>
        <span class="n">new_h</span><span class="p">,</span> <span class="n">new_cell</span> <span class="o">=</span> <span class="n">outputs</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="n">outputs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="p">[</span><span class="n">weights</span><span class="p">,</span> <span class="n">old_cell</span><span class="p">]</span>
        <span class="n">ctx</span><span class="o">.</span><span class="n">save_for_backward</span><span class="p">(</span><span class="o">*</span><span class="n">variables</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_h</span><span class="p">,</span> <span class="n">new_cell</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">backward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">grad_h</span><span class="p">,</span> <span class="n">grad_cell</span><span class="p">):</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="n">lltm</span><span class="o">.</span><span class="n">backward</span><span class="p">(</span>
            <span class="n">grad_h</span><span class="o">.</span><span class="n">contiguous</span><span class="p">(),</span> <span class="n">grad_cell</span><span class="o">.</span><span class="n">contiguous</span><span class="p">(),</span> <span class="o">*</span><span class="n">ctx</span><span class="o">.</span><span class="n">saved_variables</span><span class="p">)</span>
        <span class="n">d_old_h</span><span class="p">,</span> <span class="n">d_input</span><span class="p">,</span> <span class="n">d_weights</span><span class="p">,</span> <span class="n">d_bias</span><span class="p">,</span> <span class="n">d_old_cell</span><span class="p">,</span> <span class="n">d_gates</span> <span class="o">=</span> <span class="n">outputs</span>
        <span class="k">return</span> <span class="n">d_input</span><span class="p">,</span> <span class="n">d_weights</span><span class="p">,</span> <span class="n">d_bias</span><span class="p">,</span> <span class="n">d_old_h</span><span class="p">,</span> <span class="n">d_old_cell</span>


<span class="k">class</span> <span class="nc">LLTM</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_features</span><span class="p">,</span> <span class="n">state_size</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LLTM</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_features</span> <span class="o">=</span> <span class="n">input_features</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_size</span> <span class="o">=</span> <span class="n">state_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">state_size</span><span class="p">,</span> <span class="n">input_features</span> <span class="o">+</span> <span class="n">state_size</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bias</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">state_size</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_parameters</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">reset_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">stdv</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_size</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">weight</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">():</span>
            <span class="n">weight</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">uniform_</span><span class="p">(</span><span class="o">-</span><span class="n">stdv</span><span class="p">,</span> <span class="o">+</span><span class="n">stdv</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">LLTMFunction</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bias</span><span class="p">,</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="performance-comparison">
<h4>Performance Comparison<a class="headerlink" href="#performance-comparison" title="Permalink to this headline">¶</a></h4>
<p>Now that we are able to use and call our C++ code from PyTorch, we can run a
small benchmark to see how much performance we gained from rewriting our op in
C++. We’ll run the LLTM forwards and backwards a few times and measure the
duration:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">torch</span>

<span class="n">batch_size</span> <span class="o">=</span> <span class="mi">16</span>
<span class="n">input_features</span> <span class="o">=</span> <span class="mi">32</span>
<span class="n">state_size</span> <span class="o">=</span> <span class="mi">128</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">input_features</span><span class="p">)</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">state_size</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">state_size</span><span class="p">)</span>

<span class="n">rnn</span> <span class="o">=</span> <span class="n">LLTM</span><span class="p">(</span><span class="n">input_features</span><span class="p">,</span> <span class="n">state_size</span><span class="p">)</span>

<span class="n">forward</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">backward</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100000</span><span class="p">):</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">new_h</span><span class="p">,</span> <span class="n">new_C</span> <span class="o">=</span> <span class="n">rnn</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
    <span class="n">forward</span> <span class="o">+=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>

    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="p">(</span><span class="n">new_h</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">+</span> <span class="n">new_C</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
    <span class="n">backward</span> <span class="o">+=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Forward: </span><span class="si">{:.3f}</span><span class="s1"> us | Backward </span><span class="si">{:.3f}</span><span class="s1"> us&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">forward</span> <span class="o">*</span> <span class="mf">1e6</span><span class="o">/</span><span class="mf">1e5</span><span class="p">,</span> <span class="n">backward</span> <span class="o">*</span> <span class="mf">1e6</span><span class="o">/</span><span class="mf">1e5</span><span class="p">))</span>
</pre></div>
</div>
<p>If we run this code with the original LLTM we wrote in pure Python at the start
of this post, we get the following numbers (on my machine):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Forward</span><span class="p">:</span> <span class="mf">506.480</span> <span class="n">us</span> <span class="o">|</span> <span class="n">Backward</span> <span class="mf">444.694</span> <span class="n">us</span>
</pre></div>
</div>
<p>and with our new C++ version:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Forward</span><span class="p">:</span> <span class="mf">349.335</span> <span class="n">us</span> <span class="o">|</span> <span class="n">Backward</span> <span class="mf">443.523</span> <span class="n">us</span>
</pre></div>
</div>
<p>We can already see a significant speedup for the forward function (more than
30%). For the backward function a speedup is visible, albeit not major one. The
backward pass I wrote above was not particularly optimized and could definitely
be improved. Also, PyTorch’s automatic differentiation engine can automatically
parallelize computation graphs, may use a more efficient flow of operations
overall, and is also implemented in C++, so it’s expected to be fast.
Nevertheless, this is a good start.</p>
</div>
<div class="section" id="performance-on-gpu-devices">
<h4>Performance on GPU Devices<a class="headerlink" href="#performance-on-gpu-devices" title="Permalink to this headline">¶</a></h4>
<p>A wonderful fact about PyTorch’s <em>ATen</em> backend is that it abstracts the
computing device you are running on. This means the same code we wrote for CPU
can <em>also</em> run on GPU, and individual operations will correspondingly dispatch
to GPU-optimized implementations. For certain operations like matrix multiply
(like <code class="docutils literal notranslate"><span class="pre">mm</span></code> or <code class="docutils literal notranslate"><span class="pre">admm</span></code>), this is a big win. Let’s take a look at how much
performance we gain from running our C++ code with CUDA tensors. No changes to
our implementation are required, we simply need to put our tensors in GPU
memory from Python, with either adding <code class="docutils literal notranslate"><span class="pre">device=cuda_device</span></code> argument at
creation time or using <code class="docutils literal notranslate"><span class="pre">.to(cuda_device)</span></code> after creation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">torch</span>

<span class="k">assert</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">()</span>
<span class="n">cuda_device</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">(</span><span class="s2">&quot;cuda&quot;</span><span class="p">)</span>  <span class="c1"># device object representing GPU</span>

<span class="n">batch_size</span> <span class="o">=</span> <span class="mi">16</span>
<span class="n">input_features</span> <span class="o">=</span> <span class="mi">32</span>
<span class="n">state_size</span> <span class="o">=</span> <span class="mi">128</span>

<span class="c1"># Note the device=cuda_device arguments here</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">input_features</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">cuda_device</span><span class="p">)</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">state_size</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">cuda_device</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">state_size</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">cuda_device</span><span class="p">)</span>

<span class="n">rnn</span> <span class="o">=</span> <span class="n">LLTM</span><span class="p">(</span><span class="n">input_features</span><span class="p">,</span> <span class="n">state_size</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">cuda_device</span><span class="p">)</span>

<span class="n">forward</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">backward</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100000</span><span class="p">):</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">new_h</span><span class="p">,</span> <span class="n">new_C</span> <span class="o">=</span> <span class="n">rnn</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
    <span class="n">forward</span> <span class="o">+=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>

    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="p">(</span><span class="n">new_h</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">+</span> <span class="n">new_C</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
    <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">synchronize</span><span class="p">()</span>
    <span class="n">backward</span> <span class="o">+=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Forward: </span><span class="si">{:.3f}</span><span class="s1"> us | Backward </span><span class="si">{:.3f}</span><span class="s1"> us&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">forward</span> <span class="o">*</span> <span class="mf">1e6</span><span class="o">/</span><span class="mf">1e5</span><span class="p">,</span> <span class="n">backward</span> <span class="o">*</span> <span class="mf">1e6</span><span class="o">/</span><span class="mf">1e5</span><span class="p">))</span>
</pre></div>
</div>
<p>Once more comparing our plain PyTorch code with our C++ version, now both
running on CUDA devices, we again see performance gains. For Python/PyTorch:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Forward</span><span class="p">:</span> <span class="mf">187.719</span> <span class="n">us</span> <span class="o">|</span> <span class="n">Backward</span> <span class="mf">410.815</span> <span class="n">us</span>
</pre></div>
</div>
<p>And C++/ATen:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Forward</span><span class="p">:</span> <span class="mf">149.802</span> <span class="n">us</span> <span class="o">|</span> <span class="n">Backward</span> <span class="mf">393.458</span> <span class="n">us</span>
</pre></div>
</div>
<p>That’s a great overall speedup compared to non-CUDA code. However, we can pull
even more performance out of our C++ code by writing custom CUDA kernels, which
we’ll dive into soon. Before that, let’s dicuss another way of building your C++
extensions.</p>
</div>
</div>
<div class="section" id="jit-compiling-extensions">
<h3>JIT Compiling Extensions<a class="headerlink" href="#jit-compiling-extensions" title="Permalink to this headline">¶</a></h3>
<p>Previously, I mentioned there were two ways of building C++ extensions: using
<code class="xref py py-mod docutils literal notranslate"><span class="pre">setuptools</span></code> or just in time (JIT). Having covered the former, let’s
elaborate on the latter. The JIT compilation mechanism provides you with a way
of compiling and loading your extensions on the fly by calling a simple
function in PyTorch’s API called <code class="xref py py-func docutils literal notranslate"><span class="pre">torch.utils.cpp_extension.load()</span></code>. For
the LLTM, this would look as simple as this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">torch.utils.cpp_extension</span> <span class="k">import</span> <span class="n">load</span>

<span class="n">lltm</span> <span class="o">=</span> <span class="n">load</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;lltm&quot;</span><span class="p">,</span> <span class="n">sources</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;lltm.cpp&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>Here, we provide the function with the same information as for
<code class="xref py py-mod docutils literal notranslate"><span class="pre">setuptools</span></code>. In the background, this will do the following:</p>
<ol class="arabic simple">
<li>Create a temporary directory <code class="docutils literal notranslate"><span class="pre">/tmp/torch_extensions/lltm</span></code>,</li>
<li>Emit a <a class="reference external" href="https://ninja-build.org/">Ninja</a> build file into that temporary directory,</li>
<li>Compile your source files into a shared library,</li>
<li>Import this shared library as a Python module.</li>
</ol>
<p>In fact, if you pass <code class="docutils literal notranslate"><span class="pre">verbose=True</span></code> to <code class="xref py py-func docutils literal notranslate"><span class="pre">cpp_extension.load()</span></code>, you will
be informed about the process:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Using</span> <span class="o">/</span><span class="n">tmp</span><span class="o">/</span><span class="n">torch_extensions</span> <span class="k">as</span> <span class="n">PyTorch</span> <span class="n">extensions</span> <span class="n">root</span><span class="o">...</span>
<span class="n">Creating</span> <span class="n">extension</span> <span class="n">directory</span> <span class="o">/</span><span class="n">tmp</span><span class="o">/</span><span class="n">torch_extensions</span><span class="o">/</span><span class="n">lltm</span><span class="o">...</span>
<span class="n">Emitting</span> <span class="n">ninja</span> <span class="n">build</span> <span class="n">file</span> <span class="o">/</span><span class="n">tmp</span><span class="o">/</span><span class="n">torch_extensions</span><span class="o">/</span><span class="n">lltm</span><span class="o">/</span><span class="n">build</span><span class="o">.</span><span class="n">ninja</span><span class="o">...</span>
<span class="n">Building</span> <span class="n">extension</span> <span class="n">module</span> <span class="n">lltm</span><span class="o">...</span>
<span class="n">Loading</span> <span class="n">extension</span> <span class="n">module</span> <span class="n">lltm</span><span class="o">...</span>
</pre></div>
</div>
<p>The resulting Python module will be exactly the same as produced by setuptools,
but removes the requirement of having to maintain a separate <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> build
file. If your setup is more complicated and you do need the full power of
<code class="xref py py-mod docutils literal notranslate"><span class="pre">setuptools</span></code>, you <em>can</em> write your own <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> – but in many cases
this JIT technique will do just fine. The first time you run through this line,
it will take some time, as the extension is compiling in the background. Since
we use the Ninja build system to build your sources, re-compilation is
incremental and thus re-loading the extension when you run your Python module a
second time is fast and has low overhead if you didn’t change the extension’s
source files.</p>
</div>
</div>
<div class="section" id="writing-a-mixed-c-cuda-extension">
<h2>Writing a Mixed C++/CUDA extension<a class="headerlink" href="#writing-a-mixed-c-cuda-extension" title="Permalink to this headline">¶</a></h2>
<p>To really take our implementation to the next level, we can hand-write parts of
our forward and backward passes with custom CUDA kernels. For the LLTM, this has
the prospect of being particularly effective, as there are a large number of
pointwise operations in sequence, that can all be fused and parallelized in a
single CUDA kernel. Let’s see how we could write such a CUDA kernel and
integrate it with PyTorch using this extension mechanism.</p>
<p>The general strategy for writing a CUDA extension is to first write a C++ file
which defines the functions that will be called from Python, and binds those
functions to Python with pybind11. Furthermore, this file will also <em>declare</em>
functions that are defined in CUDA (<code class="docutils literal notranslate"><span class="pre">.cu</span></code>) files. The C++ functions will then
do some checks and ultimately forward its calls to the CUDA functions. In the
CUDA files, we write our actual CUDA kernels. The <code class="xref py py-mod docutils literal notranslate"><span class="pre">cpp_extension</span></code> package
will then take care of compiling the C++ sources with a C++ compiler like
<code class="docutils literal notranslate"><span class="pre">gcc</span></code> and the CUDA sources with NVIDIA’s <code class="docutils literal notranslate"><span class="pre">nvcc</span></code> compiler. This ensures that
each compiler takes care of files it knows best to compile. Ultimately, they
will be linked into one shared library that is available to us from Python
code.</p>
<p>We’ll start with the C++ file, which we’ll call <code class="docutils literal notranslate"><span class="pre">lltm_cuda.cpp</span></code>, for example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;torch/torch.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="c1">// CUDA forward declarations</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">at</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">lltm_cuda_forward</span><span class="p">(</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">input</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">weights</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">bias</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">old_h</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">old_cell</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">at</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">lltm_cuda_backward</span><span class="p">(</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">grad_h</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">grad_cell</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">new_cell</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">input_gate</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">output_gate</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">candidate_cell</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">X</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">gate_weights</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">weights</span><span class="p">);</span>

<span class="c1">// C++ interface</span>

<span class="cp">#define CHECK_CUDA(x) AT_ASSERT(x.type().is_cuda(), #x &quot; must be a CUDA tensor&quot;)</span>
<span class="cp">#define CHECK_CONTIGUOUS(x) AT_ASSERT(x.is_contiguous(), #x &quot; must be contiguous&quot;)</span>
<span class="cp">#define CHECK_INPUT(x) CHECK_CUDA(x); CHECK_CONTIGUOUS(x)</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">at</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">lltm_forward</span><span class="p">(</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">input</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">weights</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">bias</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">old_h</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">old_cell</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">CHECK_INPUT</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
  <span class="n">CHECK_INPUT</span><span class="p">(</span><span class="n">weights</span><span class="p">);</span>
  <span class="n">CHECK_INPUT</span><span class="p">(</span><span class="n">bias</span><span class="p">);</span>
  <span class="n">CHECK_INPUT</span><span class="p">(</span><span class="n">old_h</span><span class="p">);</span>
  <span class="n">CHECK_INPUT</span><span class="p">(</span><span class="n">old_cell</span><span class="p">);</span>

  <span class="k">return</span> <span class="nf">lltm_cuda_forward</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">bias</span><span class="p">,</span> <span class="n">old_h</span><span class="p">,</span> <span class="n">old_cell</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">at</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">lltm_backward</span><span class="p">(</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">grad_h</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">grad_cell</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">new_cell</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">input_gate</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">output_gate</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">candidate_cell</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">X</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">gate_weights</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">weights</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">CHECK_INPUT</span><span class="p">(</span><span class="n">grad_h</span><span class="p">);</span>
  <span class="n">CHECK_INPUT</span><span class="p">(</span><span class="n">grad_cell</span><span class="p">);</span>
  <span class="n">CHECK_INPUT</span><span class="p">(</span><span class="n">input_gate</span><span class="p">);</span>
  <span class="n">CHECK_INPUT</span><span class="p">(</span><span class="n">output_gate</span><span class="p">);</span>
  <span class="n">CHECK_INPUT</span><span class="p">(</span><span class="n">candidate_cell</span><span class="p">);</span>
  <span class="n">CHECK_INPUT</span><span class="p">(</span><span class="n">X</span><span class="p">);</span>
  <span class="n">CHECK_INPUT</span><span class="p">(</span><span class="n">gate_weights</span><span class="p">);</span>
  <span class="n">CHECK_INPUT</span><span class="p">(</span><span class="n">weights</span><span class="p">);</span>

  <span class="k">return</span> <span class="nf">lltm_cuda_backward</span><span class="p">(</span>
      <span class="n">grad_h</span><span class="p">,</span>
      <span class="n">grad_cell</span><span class="p">,</span>
      <span class="n">new_cell</span><span class="p">,</span>
      <span class="n">input_gate</span><span class="p">,</span>
      <span class="n">output_gate</span><span class="p">,</span>
      <span class="n">candidate_cell</span><span class="p">,</span>
      <span class="n">X</span><span class="p">,</span>
      <span class="n">gate_weights</span><span class="p">,</span>
      <span class="n">weights</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">PYBIND11_MODULE</span><span class="p">(</span><span class="n">TORCH_EXTENSION_NAME</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;forward&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lltm_forward</span><span class="p">,</span> <span class="s">&quot;LLTM forward (CUDA)&quot;</span><span class="p">);</span>
  <span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">&quot;backward&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lltm_backward</span><span class="p">,</span> <span class="s">&quot;LLTM backward (CUDA)&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As you can see, it is largely boilerplate, checks and forwarding to functions
that we’ll define in the CUDA file. We’ll name this file
<code class="docutils literal notranslate"><span class="pre">lltm_cuda_kernel.cu</span></code> (note the <code class="docutils literal notranslate"><span class="pre">.cu</span></code> extension!). NVCC can reasonably
compile C++11, thus we still have ATen and the C++ standard library available
to us (but not <code class="docutils literal notranslate"><span class="pre">torch.h</span></code>). Note that <code class="xref py py-mod docutils literal notranslate"><span class="pre">setuptools</span></code> cannot handle files
with the same name but different extensions, so if you use the <code class="docutils literal notranslate"><span class="pre">setup.py</span></code>
method instead of the JIT method, you must give your CUDA file a different name
than your C++ file (for the JIT method, <code class="docutils literal notranslate"><span class="pre">lltm.cpp</span></code> and <code class="docutils literal notranslate"><span class="pre">lltm.cu</span></code> would work
fine). Let’s take a small peek at what this file will look like:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;ATen/ATen.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;cuda.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cuda_runtime.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">scalar_t</span><span class="o">&gt;</span>
<span class="n">__device__</span> <span class="n">__forceinline__</span> <span class="n">scalar_t</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">scalar_t</span> <span class="n">z</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">z</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here we see the headers I just described, as well as the fact that we are using
CUDA-specific declarations like <code class="docutils literal notranslate"><span class="pre">__device__</span></code> and <code class="docutils literal notranslate"><span class="pre">__forceinline__</span></code> and
functions like <code class="docutils literal notranslate"><span class="pre">exp</span></code>. Let’s continue with a few more helper functions that
we’ll need:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">scalar_t</span><span class="o">&gt;</span>
<span class="n">__device__</span> <span class="n">__forceinline__</span> <span class="n">scalar_t</span> <span class="n">d_sigmoid</span><span class="p">(</span><span class="n">scalar_t</span> <span class="n">z</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">s</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">s</span><span class="p">)</span> <span class="o">*</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">scalar_t</span><span class="o">&gt;</span>
<span class="n">__device__</span> <span class="n">__forceinline__</span> <span class="n">scalar_t</span> <span class="n">d_tanh</span><span class="p">(</span><span class="n">scalar_t</span> <span class="n">z</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">tanh</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="n">t</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">scalar_t</span><span class="o">&gt;</span>
<span class="n">__device__</span> <span class="n">__forceinline__</span> <span class="n">scalar_t</span> <span class="n">elu</span><span class="p">(</span><span class="n">scalar_t</span> <span class="n">z</span><span class="p">,</span> <span class="n">scalar_t</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">fmax</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="o">+</span> <span class="n">fmin</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">*</span> <span class="p">(</span><span class="n">exp</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">scalar_t</span><span class="o">&gt;</span>
<span class="n">__device__</span> <span class="n">__forceinline__</span> <span class="n">scalar_t</span> <span class="n">d_elu</span><span class="p">(</span><span class="n">scalar_t</span> <span class="n">z</span><span class="p">,</span> <span class="n">scalar_t</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">e</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">d_relu</span> <span class="o">=</span> <span class="n">z</span> <span class="o">&lt;</span> <span class="mf">0.0</span> <span class="o">?</span> <span class="mf">0.0</span> <span class="o">:</span> <span class="mf">1.0</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">d_relu</span> <span class="o">+</span> <span class="p">(((</span><span class="n">alpha</span> <span class="o">*</span> <span class="p">(</span><span class="n">e</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">e</span><span class="p">)</span> <span class="o">:</span> <span class="mf">0.0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To now actually implement a function, we’ll again need two things: one function
that performs operations we don’t wish to explicitly write by hand and calls
into CUDA kernels, and then the actual CUDA kernel for the parts we want to
speed up. For the forward pass, the first function should look like this:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">at</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">lltm_cuda_forward</span><span class="p">(</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">input</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">weights</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">bias</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">old_h</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">old_cell</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">X</span> <span class="o">=</span> <span class="n">at</span><span class="o">::</span><span class="n">cat</span><span class="p">({</span><span class="n">old_h</span><span class="p">,</span> <span class="n">input</span><span class="p">},</span> <span class="cm">/*dim=*/</span><span class="mi">1</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">gates</span> <span class="o">=</span> <span class="n">at</span><span class="o">::</span><span class="n">addmm</span><span class="p">(</span><span class="n">bias</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">weights</span><span class="p">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>

  <span class="k">const</span> <span class="k">auto</span> <span class="n">batch_size</span> <span class="o">=</span> <span class="n">old_cell</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">state_size</span> <span class="o">=</span> <span class="n">old_cell</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

  <span class="k">auto</span> <span class="n">new_h</span> <span class="o">=</span> <span class="n">at</span><span class="o">::</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">old_cell</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">new_cell</span> <span class="o">=</span> <span class="n">at</span><span class="o">::</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">old_cell</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">input_gate</span> <span class="o">=</span> <span class="n">at</span><span class="o">::</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">old_cell</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">output_gate</span> <span class="o">=</span> <span class="n">at</span><span class="o">::</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">old_cell</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">candidate_cell</span> <span class="o">=</span> <span class="n">at</span><span class="o">::</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">old_cell</span><span class="p">);</span>

  <span class="k">const</span> <span class="kt">int</span> <span class="n">threads</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">dim3</span> <span class="nf">blocks</span><span class="p">((</span><span class="n">state_size</span> <span class="o">+</span> <span class="n">threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">threads</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">);</span>

  <span class="n">AT_DISPATCH_FLOATING_TYPES</span><span class="p">(</span><span class="n">gates</span><span class="p">.</span><span class="n">type</span><span class="p">(),</span> <span class="s">&quot;lltm_forward_cuda&quot;</span><span class="p">,</span> <span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span>
    <span class="n">lltm_cuda_forward_kernel</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span> <span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span>
        <span class="n">gates</span><span class="p">.</span><span class="n">data</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">old_cell</span><span class="p">.</span><span class="n">data</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">new_h</span><span class="p">.</span><span class="n">data</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">new_cell</span><span class="p">.</span><span class="n">data</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">input_gate</span><span class="p">.</span><span class="n">data</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">output_gate</span><span class="p">.</span><span class="n">data</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">candidate_cell</span><span class="p">.</span><span class="n">data</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">state_size</span><span class="p">);</span>
  <span class="p">}));</span>

  <span class="k">return</span> <span class="p">{</span><span class="n">new_h</span><span class="p">,</span> <span class="n">new_cell</span><span class="p">,</span> <span class="n">input_gate</span><span class="p">,</span> <span class="n">output_gate</span><span class="p">,</span> <span class="n">candidate_cell</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">gates</span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The main point of interest here is the <code class="docutils literal notranslate"><span class="pre">AT_DISPATCH_FLOATING_TYPES</span></code> macro and
the kernel launch (indicated by the <code class="docutils literal notranslate"><span class="pre">&lt;&lt;&lt;...&gt;&gt;&gt;</span></code>). While ATen abstracts away
the device and datatype of the tensors we deal with, a tensor will, at runtime,
still be backed by memory of a concrete type on a concrete device. As such, we
need a way of determining at runtime what type a tensor is and then selectively
call functions with the corresponding correct type signature. Done manually,
this would (conceptually) look something like this:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">switch</span> <span class="p">(</span><span class="n">tensor</span><span class="p">.</span><span class="n">type</span><span class="p">().</span><span class="n">scalarType</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">at</span><span class="o">::</span><span class="n">ScalarType</span><span class="o">::</span><span class="nl">Double</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">function</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tensor</span><span class="p">.</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">());</span>
  <span class="k">case</span> <span class="n">at</span><span class="o">::</span><span class="n">ScalarType</span><span class="o">::</span><span class="nl">Float</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">function</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">tensor</span><span class="p">.</span><span class="n">data</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">());</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The purpose of <code class="docutils literal notranslate"><span class="pre">AT_DISPATCH_FLOATING_TYPES</span></code> is to take care of this dispatch
for us. It takes a type (<code class="docutils literal notranslate"><span class="pre">gates.type()</span></code> in our case), a name (for error
messages) and a lambda function. Inside this lambda function, the type alias
<code class="docutils literal notranslate"><span class="pre">scalar_t</span></code> is available and is defined as the type that the tensor actually
is at runtime in that context. As such, if we have a template function (which
our CUDA kernel will be), we can instantiate it with this <code class="docutils literal notranslate"><span class="pre">scalar_t</span></code> alias,
and the correct function will be called. In this case, we also want to retrieve
the data pointers of the tensors as pointers of that <code class="docutils literal notranslate"><span class="pre">scalar_t</span></code> type. If you
wanted to dispatch over all types and not just floating point types (<code class="docutils literal notranslate"><span class="pre">Float</span></code>
and <code class="docutils literal notranslate"><span class="pre">Double</span></code>), you can use <code class="docutils literal notranslate"><span class="pre">AT_DISPATCH_ALL_TYPES</span></code>.</p>
<p>Note that we perform some operations with plain ATen. These operations will
still run on the GPU, but using ATen’s default implementations. This makes
sense, because ATen will use highly optimized routines for things like matrix
multiplies (e.g. <code class="docutils literal notranslate"><span class="pre">addmm</span></code>) or convolutions which would be much harder to
implement and improve ourselves.</p>
<p>As for the kernel launch itself, we are here specifying that each CUDA block
will have 1024 threads, and that the entire GPU grid is split into as many
blocks of <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">x</span> <span class="pre">1024</span></code> threads as are required to fill our matrices with one
thread per component. For example, if our state size was 2048 and our batch
size 4, we’d launch a total of <code class="docutils literal notranslate"><span class="pre">4</span> <span class="pre">x</span> <span class="pre">2</span> <span class="pre">=</span> <span class="pre">8</span></code> blocks with each 1024 threads. If
you’ve never heard of CUDA “blocks” or “grids” before, an <a class="reference external" href="https://devblogs.nvidia.com/even-easier-introduction-cuda">introductory read
about CUDA</a> may
help.</p>
<p>The actual CUDA kernel is fairly simple (if you’ve ever programmed GPUs before):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">scalar_t</span><span class="o">&gt;</span>
<span class="n">__global__</span> <span class="kt">void</span> <span class="n">lltm_cuda_forward_kernel</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">scalar_t</span><span class="o">*</span> <span class="n">__restrict__</span> <span class="n">gates</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar_t</span><span class="o">*</span> <span class="n">__restrict__</span> <span class="n">old_cell</span><span class="p">,</span>
    <span class="n">scalar_t</span><span class="o">*</span> <span class="n">__restrict__</span> <span class="n">new_h</span><span class="p">,</span>
    <span class="n">scalar_t</span><span class="o">*</span> <span class="n">__restrict__</span> <span class="n">new_cell</span><span class="p">,</span>
    <span class="n">scalar_t</span><span class="o">*</span> <span class="n">__restrict__</span> <span class="n">input_gate</span><span class="p">,</span>
    <span class="n">scalar_t</span><span class="o">*</span> <span class="n">__restrict__</span> <span class="n">output_gate</span><span class="p">,</span>
    <span class="n">scalar_t</span><span class="o">*</span> <span class="n">__restrict__</span> <span class="n">candidate_cell</span><span class="p">,</span>
    <span class="kt">size_t</span> <span class="n">state_size</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">column</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">state_size</span> <span class="o">+</span> <span class="n">column</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">gates_row</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="p">(</span><span class="n">state_size</span> <span class="o">*</span> <span class="mi">3</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">column</span> <span class="o">&lt;</span> <span class="n">state_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">input_gate</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">gates</span><span class="p">[</span><span class="n">gates_row</span> <span class="o">+</span> <span class="n">column</span><span class="p">]);</span>
    <span class="n">output_gate</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">gates</span><span class="p">[</span><span class="n">gates_row</span> <span class="o">+</span> <span class="n">state_size</span> <span class="o">+</span> <span class="n">column</span><span class="p">]);</span>
    <span class="n">candidate_cell</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">elu</span><span class="p">(</span><span class="n">gates</span><span class="p">[</span><span class="n">gates_row</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">state_size</span> <span class="o">+</span> <span class="n">column</span><span class="p">]);</span>
    <span class="n">new_cell</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span>
        <span class="n">old_cell</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+</span> <span class="n">candidate_cell</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">*</span> <span class="n">input_gate</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="n">new_h</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">tanh</span><span class="p">(</span><span class="n">new_cell</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="o">*</span> <span class="n">output_gate</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>What’s primarily interesting here is that we are able to compute all of these
pointwise operations entirely in parallel for each individual component in our
gate matrices. If you imagine having to do this with a giant <code class="docutils literal notranslate"><span class="pre">for</span></code> loop over
a million elements in serial, you can see why this would be much faster.</p>
<p>The backwards pass follows much the same pattern and I won’t elaborate further
on it:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">scalar_t</span><span class="o">&gt;</span>
<span class="n">__global__</span> <span class="kt">void</span> <span class="n">lltm_cuda_backward_kernel</span><span class="p">(</span>
    <span class="n">scalar_t</span><span class="o">*</span> <span class="n">__restrict__</span> <span class="n">d_old_cell</span><span class="p">,</span>
    <span class="n">scalar_t</span><span class="o">*</span> <span class="n">__restrict__</span> <span class="n">d_gates</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar_t</span><span class="o">*</span> <span class="n">__restrict__</span> <span class="n">grad_h</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar_t</span><span class="o">*</span> <span class="n">__restrict__</span> <span class="n">grad_cell</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar_t</span><span class="o">*</span> <span class="n">__restrict__</span> <span class="n">new_cell</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar_t</span><span class="o">*</span> <span class="n">__restrict__</span> <span class="n">input_gate</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar_t</span><span class="o">*</span> <span class="n">__restrict__</span> <span class="n">output_gate</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar_t</span><span class="o">*</span> <span class="n">__restrict__</span> <span class="n">candidate_cell</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">scalar_t</span><span class="o">*</span> <span class="n">__restrict__</span> <span class="n">gate_weights</span><span class="p">,</span>
    <span class="kt">size_t</span> <span class="n">state_size</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">column</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">state_size</span> <span class="o">+</span> <span class="n">column</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">gates_row</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="p">(</span><span class="n">state_size</span> <span class="o">*</span> <span class="mi">3</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">column</span> <span class="o">&lt;</span> <span class="n">state_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">d_output_gate</span> <span class="o">=</span> <span class="n">tanh</span><span class="p">(</span><span class="n">new_cell</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="o">*</span> <span class="n">grad_h</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">d_tanh_new_cell</span> <span class="o">=</span> <span class="n">output_gate</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">*</span> <span class="n">grad_h</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">d_new_cell</span> <span class="o">=</span>
        <span class="n">d_tanh</span><span class="p">(</span><span class="n">new_cell</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="o">*</span> <span class="n">d_tanh_new_cell</span> <span class="o">+</span> <span class="n">grad_cell</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>


    <span class="n">d_old_cell</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">d_new_cell</span><span class="p">;</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">d_candidate_cell</span> <span class="o">=</span> <span class="n">input_gate</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">*</span> <span class="n">d_new_cell</span><span class="p">;</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">d_input_gate</span> <span class="o">=</span> <span class="n">candidate_cell</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">*</span> <span class="n">d_new_cell</span><span class="p">;</span>


    <span class="k">const</span> <span class="k">auto</span> <span class="n">input_gate_index</span> <span class="o">=</span> <span class="n">gates_row</span> <span class="o">+</span> <span class="n">column</span><span class="p">;</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">output_gate_index</span> <span class="o">=</span> <span class="n">gates_row</span> <span class="o">+</span> <span class="n">state_size</span> <span class="o">+</span> <span class="n">column</span><span class="p">;</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">candidate_cell_index</span> <span class="o">=</span> <span class="n">gates_row</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">state_size</span> <span class="o">+</span> <span class="n">column</span><span class="p">;</span>

    <span class="n">d_gates</span><span class="p">[</span><span class="n">input_gate_index</span><span class="p">]</span> <span class="o">=</span>
        <span class="n">d_input_gate</span> <span class="o">*</span> <span class="n">d_sigmoid</span><span class="p">(</span><span class="n">gate_weights</span><span class="p">[</span><span class="n">input_gate_index</span><span class="p">]);</span>
    <span class="n">d_gates</span><span class="p">[</span><span class="n">output_gate_index</span><span class="p">]</span> <span class="o">=</span>
        <span class="n">d_output_gate</span> <span class="o">*</span> <span class="n">d_sigmoid</span><span class="p">(</span><span class="n">gate_weights</span><span class="p">[</span><span class="n">output_gate_index</span><span class="p">]);</span>
    <span class="n">d_gates</span><span class="p">[</span><span class="n">candidate_cell_index</span><span class="p">]</span> <span class="o">=</span>
        <span class="n">d_candidate_cell</span> <span class="o">*</span> <span class="n">d_elu</span><span class="p">(</span><span class="n">gate_weights</span><span class="p">[</span><span class="n">candidate_cell_index</span><span class="p">]);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">at</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">lltm_cuda_backward</span><span class="p">(</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">grad_h</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">grad_cell</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">new_cell</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">input_gate</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">output_gate</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">candidate_cell</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">X</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">gate_weights</span><span class="p">,</span>
    <span class="n">at</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">weights</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">d_old_cell</span> <span class="o">=</span> <span class="n">at</span><span class="o">::</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">new_cell</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">d_gates</span> <span class="o">=</span> <span class="n">at</span><span class="o">::</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">gate_weights</span><span class="p">);</span>

  <span class="k">const</span> <span class="k">auto</span> <span class="n">batch_size</span> <span class="o">=</span> <span class="n">new_cell</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">state_size</span> <span class="o">=</span> <span class="n">new_cell</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

  <span class="k">const</span> <span class="kt">int</span> <span class="n">threads</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">dim3</span> <span class="nf">blocks</span><span class="p">((</span><span class="n">state_size</span> <span class="o">+</span> <span class="n">threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">threads</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">);</span>

  <span class="n">AT_DISPATCH_FLOATING_TYPES</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">type</span><span class="p">(),</span> <span class="s">&quot;lltm_forward_cuda&quot;</span><span class="p">,</span> <span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span>
    <span class="n">lltm_cuda_backward_kernel</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="o">&gt;&lt;&lt;&lt;</span><span class="n">blocks</span><span class="p">,</span> <span class="n">threads</span><span class="o">&gt;&gt;&gt;</span><span class="p">(</span>
        <span class="n">d_old_cell</span><span class="p">.</span><span class="n">data</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">d_gates</span><span class="p">.</span><span class="n">data</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">grad_h</span><span class="p">.</span><span class="n">contiguous</span><span class="p">().</span><span class="n">data</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">grad_cell</span><span class="p">.</span><span class="n">contiguous</span><span class="p">().</span><span class="n">data</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">new_cell</span><span class="p">.</span><span class="n">contiguous</span><span class="p">().</span><span class="n">data</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">input_gate</span><span class="p">.</span><span class="n">contiguous</span><span class="p">().</span><span class="n">data</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">output_gate</span><span class="p">.</span><span class="n">contiguous</span><span class="p">().</span><span class="n">data</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">candidate_cell</span><span class="p">.</span><span class="n">contiguous</span><span class="p">().</span><span class="n">data</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">gate_weights</span><span class="p">.</span><span class="n">contiguous</span><span class="p">().</span><span class="n">data</span><span class="o">&lt;</span><span class="n">scalar_t</span><span class="o">&gt;</span><span class="p">(),</span>
        <span class="n">state_size</span><span class="p">);</span>
  <span class="p">}));</span>

  <span class="k">auto</span> <span class="n">d_weights</span> <span class="o">=</span> <span class="n">d_gates</span><span class="p">.</span><span class="n">t</span><span class="p">().</span><span class="n">mm</span><span class="p">(</span><span class="n">X</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">d_bias</span> <span class="o">=</span> <span class="n">d_gates</span><span class="p">.</span><span class="n">sum</span><span class="p">(</span><span class="cm">/*dim=*/</span><span class="mi">0</span><span class="p">,</span> <span class="cm">/*keepdim=*/</span><span class="nb">true</span><span class="p">);</span>

  <span class="k">auto</span> <span class="n">d_X</span> <span class="o">=</span> <span class="n">d_gates</span><span class="p">.</span><span class="n">mm</span><span class="p">(</span><span class="n">weights</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">d_old_h</span> <span class="o">=</span> <span class="n">d_X</span><span class="p">.</span><span class="n">slice</span><span class="p">(</span><span class="cm">/*dim=*/</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">state_size</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">d_input</span> <span class="o">=</span> <span class="n">d_X</span><span class="p">.</span><span class="n">slice</span><span class="p">(</span><span class="cm">/*dim=*/</span><span class="mi">1</span><span class="p">,</span> <span class="n">state_size</span><span class="p">);</span>

  <span class="k">return</span> <span class="p">{</span><span class="n">d_old_h</span><span class="p">,</span> <span class="n">d_input</span><span class="p">,</span> <span class="n">d_weights</span><span class="p">,</span> <span class="n">d_bias</span><span class="p">,</span> <span class="n">d_old_cell</span><span class="p">,</span> <span class="n">d_gates</span><span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="integrating-a-c-cuda-operation-with-pytorch">
<h3>Integrating a C++/CUDA Operation with PyTorch<a class="headerlink" href="#integrating-a-c-cuda-operation-with-pytorch" title="Permalink to this headline">¶</a></h3>
<p>Integration of our CUDA-enabled op with PyTorch is again very straightforward.
If you want to write a <code class="docutils literal notranslate"><span class="pre">setup.py</span></code> script, it could look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">setuptools</span> <span class="k">import</span> <span class="n">setup</span>
<span class="kn">from</span> <span class="nn">torch.utils.cpp_extension</span> <span class="k">import</span> <span class="n">BuildExtension</span><span class="p">,</span> <span class="n">CUDAExtension</span>

<span class="n">setup</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;lltm&#39;</span><span class="p">,</span>
    <span class="n">ext_modules</span><span class="o">=</span><span class="p">[</span>
        <span class="n">CUDAExtension</span><span class="p">(</span><span class="s1">&#39;lltm_cuda&#39;</span><span class="p">,</span> <span class="p">[</span>
            <span class="s1">&#39;lltm_cuda.cpp&#39;</span><span class="p">,</span>
            <span class="s1">&#39;lltm_cuda_kernel.cu&#39;</span><span class="p">,</span>
        <span class="p">])</span>
    <span class="p">],</span>
    <span class="n">cmdclass</span><span class="o">=</span><span class="p">{</span>
        <span class="s1">&#39;build_ext&#39;</span><span class="p">:</span> <span class="n">BuildExtension</span>
    <span class="p">})</span>
</pre></div>
</div>
<p>Instead of <code class="xref py py-func docutils literal notranslate"><span class="pre">CppExtension()</span></code>, we now use <code class="xref py py-func docutils literal notranslate"><span class="pre">CUDAExtension()</span></code>. We can just
specify the <code class="docutils literal notranslate"><span class="pre">.cu</span></code> file along with the <code class="docutils literal notranslate"><span class="pre">.cpp</span></code> files – the library takes
care of all the hassle this entails for you. The JIT mechanism is even
simpler:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">torch.utils.cpp_extension</span> <span class="k">import</span> <span class="n">load</span>

<span class="n">lltm</span> <span class="o">=</span> <span class="n">load</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;lltm&#39;</span><span class="p">,</span> <span class="n">sources</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;lltm_cuda.cpp&#39;</span><span class="p">,</span> <span class="s1">&#39;lltm_cuda_kernel.cu&#39;</span><span class="p">])</span>
</pre></div>
</div>
<div class="section" id="id2">
<h4>Performance Comparison<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>Our hope was that parallelizing and fusing the pointwise operations of our code
with CUDA would improve the performance of our LLTM. Let’s see if that holds
true. We can run the code I listed earlier to run a benchmark. Our fastest
version earlier was the CUDA-based C++ code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Forward</span><span class="p">:</span> <span class="mf">149.802</span> <span class="n">us</span> <span class="o">|</span> <span class="n">Backward</span> <span class="mf">393.458</span> <span class="n">us</span>
</pre></div>
</div>
<p>And now with our custom CUDA kernel:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Forward</span><span class="p">:</span> <span class="mf">129.431</span> <span class="n">us</span> <span class="o">|</span> <span class="n">Backward</span> <span class="mf">304.641</span> <span class="n">us</span>
</pre></div>
</div>
<p>More performance increases!</p>
</div>
</div>
</div>
<div class="section" id="conclusion">
<h2>Conclusion<a class="headerlink" href="#conclusion" title="Permalink to this headline">¶</a></h2>
<p>You should now be equipped with a good overview of PyTorch’s C++ extension
mechanism as well as a motivation for using them. You can find the code examples
displayed in this note <a class="reference external" href="https://github.com/pytorch/extension-cpp">here</a>. If you have
questions, please use <a class="reference external" href="https://discuss.pytorch.org">the forums</a>.</p>
</div>
</div>


           </div>
           <div class="articleComments">

           </div>
          </div>
          <footer>

    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">


        <a href="super_resolution_with_caffe2.html" class="btn btn-neutral" title="Transfering a model from PyTorch to Caffe2 and Mobile using ONNX" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>

    </div>


  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, PyTorch.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.

</footer>

        </div>
      </div>

    </section>

  </div>





    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'0.4.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>





    <script type="text/javascript" src="../_static/js/theme.js"></script>




  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-71919972-3', 'auto');
  ga('send', 'pageview');

</script>


</body>
</html>